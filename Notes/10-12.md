# 10-12 Notes
- Been writing more code in notes since I don't have the repo cloned on my Linux laptop (gotta clean it up first its too big)

# More work on implementing custom events

BasicHandler.java
```
@FunctionalInterface
public interface BasicHandler {
  public void handle(String input_string);
}
```

- Here the annotation FunctionalInterface tells Java this function can use the lamdba arrow function. 
If the annotation isn't there it may still work, but don't chance it.

BasicWidget.java
```
public class BasicWidget extends GridPane {
  private Vector<BasicHandler> handlers = new Vector<BasicHandler>();
  
  public BasicWidget() {
    TextField tf = new TextField();
    add(tf, 0, 0);
    
    Button b = new Button("Submit");
    add(b, 1, 0);
    
    b.setOnAction(
      (event) -> {
        String str = tf.getText();
        for (BasicHandler bh: handlers) {
          bh.handle(str);
        }
      });
  }
  
  public void addBasicHandler(BasicHandler bh) { 
  // BasicHandler is the same as setOnAction(), that is you can use setOnAction with it without issues as long as you
  // declare it as the interface above in BasicHandler.java.
    handlers.add(bh);
  }
  
}
```

Runner.java
```
public class BasicRunner extends Application {
  @Override
  public void start(Stage stage) {
      BasicWidget root = new BasicWidget();

      root.addBasicHandler(
      (String str) -> {System.out.println(str);
      });
      
      Scene scene = new Scene(root, 600, 800);
      
      stage.setTitle("In Class");
      stage.setScene(scene);
      stage.show();
  }

}

```

- So we wrote our "event" but used a basic parameters like 
```
    root.addBasicHandler(
        (String str) -> {
          //blahh
        });
```
 but normally people prefer that you use an event just like all other functions.
```
     root.addBasicHandler(
        (event) -> {
          //blahh
        });
```
and your interface like 

```
public void handle(ActionEvent e)
```

However, this might seem unncessarily verbose to the user, so you may wish to just use a string or number or whatever you want. The advantage of using an event is that they have some idea of the scope of the layout that you are using like GridPane or VBox. 

- For FXML 

```
// loader = FXMLLoader class.
Controller c = loader.getController();
c.addBasicHandler((String str) -> {// blah });
```

# Model-View-Controller Pattern
-  View: display current program state and only display the state; generate events that represent user action; 
contains functions to display states
-  Model: non-graphical perform task or use some other library; contains functions to start/stop operations; events to report
status
- Controller: defines the behavior of the Viewer; ties the above two together; in many scenarios, the Controller receives the events from the Model and Controllerâ€”the two never talk to one another.

- Example flow: 
  - View to Model: Views send an event to the Controller; Controller consumes the event and passes the event to a method in the Model.
     - e.g. A download button is clicked, gets passed to the Controller, and the Model has a startDownload() method that talks to the Download Engine.
  - Model to View: Model sends an event to the Controller, which passes it to the view and calls a function to update the display of state.
  
## Example MVC

Lets say we have a interface like a top box of sliders and a submit button with another box below depicting a graph

Relevant functions and events

View                    Controller                    Model
   startRequested
   cancelRequested
   getSettings()
   showProgress()
   setRunning()
   setReady()
   
- For the view we'd like to separate all the functions into separate states.
  - so for math model
  
      init to running transition = start button
      running to init transition = cancel button
      running to init = finished event 
      
 Here's my shit flow diagram, parentheses are tranistion labels:
            <- (finished)
         (start) 
      init -> running
            <- (cancel)
            <- (failed)
            
- Where should we confirm that the data input is correct?
    - Most people said View and I agreed, but Model is the step that may be more correct. If it's easy to verify, then do it in the View.
